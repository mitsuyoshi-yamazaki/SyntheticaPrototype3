## 概要

Synthetica Scriptは、COMPUTERが実行するプログラムを記述するプログラミング言語の総称である。
COMPUTERが実行するのはCOMPUTERのメモリに格納されたバイト列を命令セットとして解釈したもので、本ファイルではこの命令セットと、命令セットを人間が記述するためのアセンブリ言語の仕様を策定する。
今後のバージョンでは、アセンブリ言語をラップして構造化プログラミングの仕組みを導入したC言語コンパイラと、GUIベースプログラミングを追加する予定である。どちらもアセンブリ言語を経由して命令セットへ変換される。

## 仕様バージョン

本仕様はゲーム世界仕様（game-world-requirement.md）のバージョンに準拠する。

- **現在のバージョン**: 3.3.0

## アーキテクチャ仕様

COMPUTERのアーキテクチャ仕様について
COMPUTERは以下の機能を持つ

- プログラムカウンタ
  - プログラムカウンタは16bitの変数である
    - これによりメモリの最大容量が定まる（2^16 = 65,536）
    - メモリ容量の最大値は65,536バイト（64KB）に固定される
  - 次に実行する命令のメモリ番地を示す
  - プログラムカウンタを操作する命令以外では、命令を実行したらプログラムカウンタを命令長分進める
    - メモリの最後尾にある命令を実行した後は、プログラムカウンタはメモリの先頭を指す
- ワーキングレジスタ
  - A, B, C, Dの4本（各16bit）
- フラグ
  - キャリフラグ
  - ゼロフラグ
- メモリ領域
  - 各領域は8bit（1バイト）
  - メモリ容量の最大値は 2^16 = 65,536バイト（64KB）
  - バイトアドレッシング（16bitアドレスで1バイト単位でアクセス）
- 外部バス
  - 回路的に接続しているユニットへアクセスするためのもの
  - アクセス制御：複数COMPUTERが同じユニットにアクセスする場合、そのtickで最後に更新された状態をとる
- 動作周波数
  - COMPUTERの動作周波数は分数を取りうる（例：1命令/3tick）
  - 分数周波数の処理：各tickでCOMPUTERユニットがそのtickで何回命令を実行できるかを管理
  - 例：1/3周波数のCOMPUTERは、3tickのうち2tickは命令を実行しない（エネルギー消費もない）
  - 実行サイクル：
    - 各命令には実行サイクルパラメータを持つ
    - ひとつの命令であっても2以上の実行サイクルを持つ命令は、実行するとその実行サイクル分の動作周波数を消費する
    - 例；3命令/tickのCOMPUTERで3サイクル命令を実行すると、もうそのtickでは他の命令を実行できない
- 外部ユニットアクセス
  - COMPUTERから各ユニットにアクセスし、ユニット状態の読み取りやユニット機能の実行を行うために、各ユニットには操作用のメモリ領域が用意されている（領域の最大容量（アドレスbit幅）は8bit）
  - COMPUTERからは、ユニット種別、ユニットインデックス、ユニット操作メモリアドレス によってアクセスする
- 備考
  - 割り込み機能は持たない
    - ソフトウェアの自由度や創発性に対して大きな利点があることがわかれば将来追加する
  - セキュリティ・安全性：意図しない動作やメモリ内容の破損は進化の原動力となるため、積極的な対策は行わない
  - 無限ループ：無限ループに陥ったCOMPUTERは単にそのエージェントに不利に働くのみで、アプリケーションへの追加負荷はないため、特に対応はしない

一般的に利用されているCPUと異なり、COMPUTERにはプログラムとデータの区別がない。
プログラムとデータを分離したプログラミングをしたい場合は、プログラム的にデータ領域の実行を禁止する。

## 設計要件と方針

### 設計要件

#### 大元の要件

- 人間がプログラミング可能（創発性の低い状態で設計ができること）かつ、
- シミュレーションが動作し始めたら創発性をもつこと
- （副次的な要件）進化の仕組みはシステムとしては提供しない（エージェントに進化の機能を持たせたいとしたら、人間がその"進化"をプログラミングする、もしくは偶然により自然発生的に進化が始まるのを待つ必要がある）：これは、進化の仕組みをシステムで提供することで、進化の手法にバイアスがかかることを防止するためである

#### 具体的な要件

- メモリ上の値を確認すれば、（他ユニットの挙動はさておき）COMPUTERの動作が一意に決定できること
- 未定義オペコードは安全に処理され、プログラムの実行が継続されること

### 設計方針

#### 1. 可変長命令方式

- 命令長を固定せず、命令の最初のバイトで命令長を決定
- 1バイト命令（頻出・基本命令）、2バイト命令（オペランド付き）、3バイト命令（拡張命令）

#### 2. テンプレートマッチング方式

- 特定のメモリアドレスを直接指定せず、パターンでアドレスを探索
- Tierraの設計思想を参考

#### 3. 単一値オペコード

- 各命令は固有の単一オペコード値を持つ
- 未定義オペコードの検出が可能で、より明確なエラー処理

#### 4. 相対アドレッシング中心

- 絶対アドレスではなく、現在位置からの相対位置で指定
- コードの位置独立性を確保

#### 5. 最小限の命令セット

- チューリング完全性を保ちつつ最小限の命令数

## アセンブラ言語仕様

### メモリモデル

- メモリは16bitアドレス空間（65,536バイト = 64KB）
- 循環バッファ型（アドレス65,535の次は0）
- メモリの各領域は8bit（1バイト）
- アドレッシングモード：
  - 相対アドレス：PC相対またはレジスタ相対（3バイト命令、低コスト）
  - 絶対アドレス：直接アドレス指定（4バイト命令、高コスト）
  - テンプレート：パターンマッチング（可変長、位置独立）

### レジスタ構成

- PC（プログラムカウンタ）: 16bit
- ワーキングレジスタ: A, B, C, D の4本（各16bit）
- スタックポインタ: 内部レジスタ（16bit）
  - 初期値: 0xFFFF（スタックはメモリ最後尾から下方向に成長）
  - PUSH時: SP = SP - 2、Memory[SP] = 値
  - POP時: 値 = Memory[SP]、SP = SP + 2
- フラグレジスタ:
  - Z（ゼロフラグ）: 最後の演算結果が0の時にセット
  - C（キャリーフラグ）: 加算時の桁上がり、減算時の桁下がりでセット

### 命令フォーマット

#### 命令長の判定

第1バイトの値により命令長が決定される：

- 0x00-0x3F: 1バイト命令（基本命令）
- 0x40-0x7F: 3バイト命令（8bitオフセット/即値）
- 0x80-0xBF: 4バイト命令（16bitアドレス/即値）
- 0xC0-0xFF: 5バイト命令（拡張命令）

### 命令一覧

注意：未定義命令を実行すると、プログラムカウンタが1進む（つまり未定義命令はすべて1バイト命令である）他はレジスタ、フラグ、メモリ等は変化しない

#### 1バイト命令（0x00-0x3F）

特にサイクル数指定のない1バイト命令は1サイクル

##### データ移動命令

- **0x00: NOP0** - テンプレート用NOP（値0）
- **0x01: NOP1** - テンプレート用NOP（値1）
- **0x02: XCHG** - レジスタAとBを交換
- **0x03: MOV_AB** - レジスタAをBにコピー
- **0x04: MOV_AD** - レジスタAをDにコピー
- **0x05: MOV_BA** - レジスタBをAにコピー
- **0x06: MOV_DA** - レジスタDをAにコピー
- **0x07: MOV_BC** - レジスタBをCにコピー
- **0x08: MOV_CB** - レジスタCをBにコピー
- **0x09: MOV_AC** - レジスタAをCにコピー
- **0x0A: MOV_CA** - レジスタCをAにコピー
- **0x0B: MOV_CD** - レジスタCをDにコピー
- **0x0C: MOV_DC** - レジスタDをCにコピー
- **0x0D: MOV_SP** - スタックポインタをAレジスタにコピー
- **0x0E: SET_SP** - Aレジスタをスタックポインタにコピー

##### 算術演算命令（16bit演算）

- **0x10: INC_A** - レジスタAをインクリメント（16bit）
- **0x11: INC_B** - レジスタBをインクリメント（16bit）
- **0x12: INC_C** - レジスタCをインクリメント（16bit）
- **0x13: INC_D** - レジスタDをインクリメント（16bit）
- **0x14: DEC_A** - レジスタAをデクリメント（16bit）
- **0x15: DEC_B** - レジスタBをデクリメント（16bit）
- **0x16: DEC_C** - レジスタCをデクリメント（16bit）
- **0x17: DEC_D** - レジスタDをデクリメント（16bit）
- **0x18: ADD_AB** - A = A + B（16bit加算、キャリーフラグ更新）
- **0x19: SUB_AB** - A = A - B（16bit減算、キャリーフラグ更新）
- **0x1A: XOR_AB** - A = A XOR B（16bit XOR、ゼロフラグ更新）
- **0x1B: AND_AB** - A = A AND B（16bit AND、ゼロフラグ更新）
- **0x1C: OR_AB** - A = A OR B（16bit OR、ゼロフラグ更新）
- **0x1D: NOT_A** - A = NOT A（16bit NOT、ゼロフラグ更新）
- **0x1E: CMP_AB** - A - B（16bit比較、フラグのみ更新、Aは変更なし）
- **0x1F: PUSH_A** - Aレジスタをスタックにプッシュ（スタック操作は2サイクル）
- **0x20: PUSH_B** - Bレジスタをスタックにプッシュ（スタック操作は2サイクル）
- **0x21: PUSH_C** - Cレジスタをスタックにプッシュ（スタック操作は2サイクル）
- **0x22: PUSH_D** - Dレジスタをスタックにプッシュ（スタック操作は2サイクル）
- **0x2E: POP_A** - スタックからAレジスタにポップ（スタック操作は2サイクル）
- **0x2F: POP_B** - スタックからBレジスタにポップ（スタック操作は2サイクル）
- **0x30: POP_C** - スタックからCレジスタにポップ（スタック操作は2サイクル）
- **0x31: POP_D** - スタックからDレジスタにポップ（スタック操作は2サイクル）

#### 3バイト命令（0x40-0x7F）

第2,3バイトは16bit符号付きオフセット（リトルエンディアン）
特にサイクル数指定のない3バイト命令は2サイクル

##### メモリアクセス命令（相対アドレス）

- **0x40: LOAD_A** - A = Memory[PC + 符号付き16bitオフセット]
  - メモリから8bitを読み込み、Aの下位8bitに格納、上位8bitは0
- **0x41: STORE_A** - Memory[PC + 符号付き16bitオフセット] = A & 0xFF
  - Aの下位8bitをメモリに書き込み
- **0x42: LOAD_IND** - A = Memory[B + 符号付き16bitオフセット]
- **0x43: STORE_IND** - Memory[B + 符号付き16bitオフセット] = A & 0xFF
- **0x44: LOAD_A_W** - A = Memory16[PC + 符号付き16bitオフセット]
  - メモリから16bitを読み込み（リトルエンディアン）
- **0x45: STORE_A_W** - Memory16[PC + 符号付き16bitオフセット] = A
  - Aの16bitをメモリに書き込み（リトルエンディアン）

##### レジスタベースメモリアクセス命令

- **0x50: LOAD_REG** - A = Memory[レジスタ値]
  - 第2バイト: レジスタ指定（0=A, 1=B, 2=C, 3=D）
  - 第3バイト: 未使用（0x00）
- **0x51: STORE_REG** - Memory[レジスタ値] = A & 0xFF
  - 第2バイト: レジスタ指定（0=A, 1=B, 2=C, 3=D）
  - 第3バイト: 未使用（0x00）
- **0x52: LOAD_IND_REG** - A = Memory[Memory16[アドレス]]（間接）
  - 第2,3バイト: 16bitアドレス
- **0x53: STORE_IND_REG** - Memory[Memory16[アドレス]] = A & 0xFF（間接）
  - 第2,3バイト: 16bitアドレス

##### 制御命令

ジャンプ命令は、ジャンプが実行される場合は3サイクル、実行されない場合は1サイクル

- **0x60: JMP** - PC = PC + 符号付き16bitオフセット
- **0x61: JZ** - ゼロフラグがセットならジャンプ
- **0x62: JNZ** - ゼロフラグがクリアならジャンプ
- **0x63: JC** - キャリーフラグがセットならジャンプ（unsigned <）
- **0x64: JNC** - キャリーフラグがクリアならジャンプ（unsigned >=）
- **0x65: CALL** - Cレジスタに戻り先を保存してジャンプ
- **0x66: JG** - 大なり（A > B after CMP_AB）
- **0x67: JLE** - 以下（A <= B after CMP_AB）
- **0x68: JGE** - 以上（A >= B after CMP_AB）
- **0x69: JL** - 小なり（A < B after CMP_AB）

##### ユニット操作命令（メモリマップドI/O）

ユニット操作命令は3サイクル

- **0x90: UNIT_MEM_READ** - 外部ユニットメモリ読み取り
  - 第2バイト: ユニット種別とインデックス（上位4bit:ユニット種別、下位4bit:ユニットインデックス）
  - 第3バイト: ユニット操作メモリアドレス（8bit）
  - 結果: Aレジスタに格納（下位8bitへ、上位は0）
- **0x91: UNIT_MEM_WRITE** - 外部ユニットメモリ書き込み
  - 第2バイト: ユニット種別とインデックス（上位4bit:ユニット種別、下位4bit:ユニットインデックス）
  - 第3バイト: ユニット操作メモリアドレス（8bit）
  - Aレジスタの下位8bitを書き込み
- **0x92: UNIT_MEM_READ_REG** - レジスタ指定で外部ユニットメモリ読み取り
  - 第2バイト: ユニット種別とインデックス（上位4bit:ユニット種別、下位4bit:ユニットインデックス）
  - 第3バイト: アドレス指定レジスタ（0=A, 1=B, 2=C, 3=D）
  - 結果: Aレジスタに格納（下位8bitへ、上位は0）
- **0x93: UNIT_MEM_WRITE_REG** - レジスタ指定で外部ユニットメモリ書き込み
  - 第2バイト: ユニット種別とインデックス（上位4bit:ユニット種別、下位4bit:ユニットインデックス）
  - 第3バイト: アドレス指定レジスタ（0=A, 1=B, 2=C, 3=D）
  - Aレジスタの下位8bitを書き込み
- **0x94: UNIT_EXISTS** - ユニット存在確認
  - 第2バイト: ユニット種別とインデックス（上位4bit:ユニット種別、下位4bit:ユニットインデックス）
  - 第3バイト: 未使用
  - 結果: Aレジスタに 1（存在）または 0（不在）

#### 4バイト命令（0x80-0xBF）

特にサイクル数指定のない4バイト命令は3サイクル
第2,3,4バイトで16bitアドレス/即値を指定（リトルエンディアン）

##### パターンマッチング命令

パターンマッチング命令は5サイクル

- **0x80: SEARCH_F** - 前方検索（可変長テンプレート）
  - 次バイト以降のNOP0/NOP1列をテンプレートとして使用
  - テンプレート終端: 最初の非NOP命令まで
  - 補完パターンをメモリ内で検索
  - 結果: 見つかった位置をBレジスタに格納、見つからなければB=0xFFFF
- **0x81: SEARCH_B** - 後方検索（SEARCH_Fと同様）
- **0x82: SEARCH_F_MAX** - 前方検索（最大距離指定）
  - 第2,3バイト: 最大検索距離（16bit）
  - 第4バイト以降: テンプレート（可変長）
- **0x83: SEARCH_B_MAX** - 後方検索（SEARCH_F_MAXと同様）

##### エネルギー計算命令（1024進法32bit演算）

エネルギー計算命令は4サイクル

- **0x95: ADD_E32** - 32bitエネルギー加算
  - A,B = A,B + C,D（上位16bit,下位16bit）
  - キャリー処理: 下位10bitがオーバーフロー時に上位へ
- **0x96: SUB_E32** - 32bitエネルギー減算
  - A,B = A,B - C,D（上位16bit,下位16bit）
  - ボロー処理: 下位が負になった場合に上位から借用
- **0x97: CMP_E32** - 32bitエネルギー比較
  - A,B と C,D を比較（結果はフラグに反映）
  - 上位16bit優先、同じ場合は下位16bitで比較
- **0x98: SHR_E10** - エネルギー値を1024で除算
  - A = A,B >> 10（10bit右シフト）
  - 上位16bitのみを結果として返す
- **0x99: SHL_E10** - エネルギー値を1024倍
  - A,B = A << 10（10bit左シフト）
  - Aの下位6bitが上位結果の下位に、Bは0になる

##### メモリアクセス命令（絶対アドレス）

- **0xA0: LOAD_ABS** - A = Memory[16bitアドレス]
  - 第2,3バイト: 16bit絶対アドレス
  - 第4バイト: 未使用（0x00）
  - メモリから8bitを読み込み、上位8bitは0
- **0xA1: STORE_ABS** - Memory[16bitアドレス] = A & 0xFF
  - 第2,3バイト: 16bit絶対アドレス
  - 第4バイト: 未使用（0x00）
- **0xA2: LOAD_ABS_W** - A = Memory16[16bitアドレス]
  - 第2,3バイト: 16bit絶対アドレス
  - 第4バイト: 未使用（0x00）
  - メモリから16bitを読み込み（リトルエンディアン）
- **0xA3: STORE_ABS_W** - Memory16[16bitアドレス] = A
  - 第2,3バイト: 16bit絶対アドレス
  - 第4バイト: 未使用（0x00）
  - 16bit値を書き込み（リトルエンディアン）

##### 間接ジャンプ命令

- **0xB0: JMP_IND** - PC = レジスタの値
  - 第2バイト: レジスタ指定（0=A, 1=B, 2=C, 3=D）
  - 第3,4バイト: 未使用（0x0000）
- **0xB1: JMP_ABS** - PC = 16bitアドレス
  - 第2,3バイト: 16bit絶対アドレス
  - 第4バイト: 未使用（0x00）
- **0xB2: RET** - PC = C（CALLからの復帰専用）
  - 第2,3,4バイト: 未使用（0x000000）

#### 5バイト命令（0xC0-0xFF）

特にサイクル数指定のない5バイト命令は3サイクル
第2-5バイトで拡張オペランドを指定

##### 拡張演算命令

- **0xC0: MUL_AB** - A = (A \* B) & 0xFFFF
  - 第2-5バイト: 未使用（0x00000000）
  - 16bit乗算、結果の下位16bitを保持
- **0xC1: DIV_AB** - A = A / B, B = A % B
  - 第2-5バイト: 未使用（0x00000000）
  - 16bit除算とモジュロ
- **0xC2: SHL** - A = A << B（論理左シフト）
  - 第2-5バイト: 未使用（0x00000000）
  - Bレジスタの下位4bitの値だけ左シフト（0-15bit）
  - シフトアウトしたビットは破棄
  - シフトアウトしたビットがある場合はキャリフラグが立つ
- **0xC3: SHR** - A = A >> B（論理右シフト）
  - 第2-5バイト: 未使用（0x00000000）
  - Bレジスタの下位4bitの値だけ右シフト（0-15bit）
  - 空いた上位ビットは0で埋める
  - シフトで失われたビットがある場合はキャリフラグが立つ
- **0xC4: SAR** - A = A >>> B（算術右シフト）
  - 第2-5バイト: 未使用（0x00000000）
  - Bレジスタの下位4bitの値だけ右シフト（0-15bit）
  - 空いた上位ビットは符号ビットで埋める
- **0xC5: CMOV_Z** - ゼロフラグがセットされている場合のみレジスタ移動
  - 第2バイト: ソースレジスタ（0=A, 1=B, 2=C, 3=D）
  - 第3バイト: 宛先レジスタ（0=A, 1=B, 2=C, 3=D）
  - 第4,5バイト: 未使用（0x0000）
  - Z=1の場合: dst = src、Z=0の場合: 何もしない
- **0xC6: CMOV_NZ** - ゼロフラグがクリアされている場合のみレジスタ移動
  - フォーマットはCMOV_Zと同じ
  - Z=0の場合: dst = src、Z=1の場合: 何もしない
- **0xC7: CMOV_C** - キャリーフラグがセットされている場合のみレジスタ移動
  - フォーマットはCMOV_Zと同じ
  - C=1の場合: dst = src、C=0の場合: 何もしない
- **0xC8: CMOV_NC** - キャリーフラグがクリアされている場合のみレジスタ移動
  - フォーマットはCMOV_Zと同じ
  - C=0の場合: dst = src、C=1の場合: 何もしない

##### 即値ロード命令

- **0xE0: LOAD_IMM** - A = 16bit即値
  - 第2,3バイト: 16bit即値（リトルエンディアン）
  - 第4,5バイト: 未使用（0x0000）
- **0xE1: LOAD_IMM_B** - B = 16bit即値
  - 第2,3バイト: 16bit即値（リトルエンディアン）
  - 第4,5バイト: 未使用（0x0000）

##### NOP命令

- **0xF0: NOP5** - 5バイトNOP（パディング用）（1サイクル）

### テンプレートマッチング仕様

#### 基本概念

- テンプレートはNOP0（値0）とNOP1（値1）の列で構成
- 補完パターンマッチング: 検索時は元パターンの0と1を反転したパターンを探す
- 可変長テンプレート: 最初の非NOP命令までがテンプレート
- 部分マッチング: 長いテンプレートに短いテンプレートの補完がマッチ可能

#### 補完パターンの例

```
定義側:  NOP1 NOP1 NOP0 NOP0  ; パターン: 1100
検索側:  NOP0 NOP0 NOP1 NOP1  ; 補完: 0011を探す
```

#### エネルギーコスト

- 基本実行コスト: 2E
- テンプレート長コスト: ceil(template_length / 2)E
- 検索距離コスト: ceil(actual_distance / 10)E
- 失敗時: 基本コスト + ceil(最大検索距離 / 10)E

#### 使用例

```
; ラベル定義（ジャンプ先）
LOOP_START:
  NOP1 NOP1 NOP0 NOP1    ; テンプレート: 1101
  MOV_AB                 ; 実際のコード開始
  ; ... ループ本体 ...

; ラベル参照（ジャンプ元）
  SEARCH_B               ; 後方検索
  NOP0 NOP0 NOP1 NOP0    ; 補完パターン: 0010を探す
  JMP_IND                ; Bレジスタ（検索結果）にジャンプ
  0x01                   ; レジスタB指定
  0x00                   ; 未使用
```

#### 自己参照の防止

補完パターンを使用するため、定義側のテンプレートが自分自身にマッチすることはない。これにより、最も近い「他の」ラベルを確実に見つけることができる。

#### 部分マッチングの動作

```
長いテンプレート:  NOP1 NOP1 NOP0 NOP0 NOP1  ; 11001
短い補完パターン:  NOP0 NOP0 NOP1              ; 001
→ 最初の3ビットの補完としてマッチ
```

### 外部ユニット操作仕様（メモリマップドI/O）

#### ユニット種別コード（上位4bit）

- 0x0: HULL
- 0x4: ASSEMBLER
- 0x8: DISASSEMBLER
- 0xC: COMPUTER
- その他: 予約

#### ユニットメモリマップ

各ユニットは固有のメモリ領域を持ち、以下のような構成：

##### HULL（16バイト）

```
0x00: 現在の格納量
0x01: 最大容量
0x02: エネルギー回収ON/OFF（0=OFF, 1=ON）
0x03: マージ対象HULL ID
0x04-0x05: エネルギー保有量（16bit、下位・上位）
0x06: 分離対象ユニット種別
0x07: 分離対象ユニットインデックス
0x08: 分離実行フラグ（1を書き込むと実行）
0x09-0x0F: 予約
```

##### ASSEMBLER（32バイト）

```
0x00-0x01: 状態（稼働中/待機中、進捗率など）
0x02-0x03: 生産中ユニット情報
0x10: 生産ユニット種別
0x11-0x1E: 生産パラメータ（種別ごとに異なる）
0x1F: 生産開始フラグ（1を書き込むと開始）
```

##### DISASSEMBLER（16バイト）

```
0x00-0x01: 状態
0x02: ターゲット指定方法（0=隣接任意、1=ユニットID指定）
0x03: ターゲットユニットID（指定時のみ）
0x04: 投入エネルギー量
0x05: 分解実行フラグ
0x06-0x0F: 予約
```

##### COMPUTER（特殊）

```
0x0000-0xFFFF: プログラムメモリ（最大64KB、サイズは生成時指定）
末尾1バイト: 外部書き換え許可フラグ（0=拒否、1=許可）
```

### アドレッシングモードの使い分け

#### 相対アドレス（推奨：低コスト）

```
; ローカル変数・作業領域
STORE_A     ; 近くのメモリに保存
0x05        ; PC+5の位置（下位バイト）
0x00        ; （上位バイト）
; ... 処理 ...
LOAD_A      ; 同じ相対位置から読み出し
0x05
0x00
```

#### 絶対アドレス（グローバル変数用）

```
; 共有メモリ領域（アドレス8000-8100を共有エリアとする）
STORE_ABS   ; 絶対アドレス8000に保存
0x40        ; 8000番地（下位バイト）
0x1F        ; （上位バイト） 0x1F40 = 8000
0x00        ; 第4バイト（未使用）

; 別の場所から読み出し
LOAD_ABS    ; 絶対アドレス8000から読み出し
0x40
0x1F
0x00
```

#### テンプレート（位置独立コード）

```
; 重要なデータの位置をマーク
IMPORTANT_DATA:
  NOP1 NOP1 NOP0 NOP0    ; マーカー: 1100
  0x00                   ; データ本体

; 後でテンプレートで検索
SEARCH_F                 ; 前方検索
NOP0 NOP0 NOP1 NOP1    ; 補完: 0011を探す
LOAD_IND                ; 見つかった位置+1から読み出し
0x01
0x00
```

### エネルギー消費

各命令の実行には以下のエネルギーを消費：

- 1バイト命令: 1E
  - エネルギー計算命令（ADD_E32, SUB_E32, CMP_E32, SHR_E10, SHL_E10）: 2E（複雑な演算のため）
  - スタック操作命令（PUSH*\*, POP*\*）: 2E（メモリアクセスを含むため）
- 3バイト命令: 3E
  - レジスタベース命令（LOAD_REG, STORE_REG）: 3E
  - 間接アドレス命令（LOAD_IND_REG, STORE_IND_REG）: 4E
- 4バイト命令: 4E
  - 絶対アドレス命令（LOAD_ABS, STORE_ABS, JMP_ABS）: 6E（高コスト）
  - レジスタベースユニット操作: 4E + 10E（ユニット操作）
- 5バイト命令: 5E
  - 即値ロード（LOAD_IMM）: 5E
  - ビットシフト命令（SHL, SHR, SAR）: 4E（ビット操作のため）
  - 条件付き移動命令（CMOV\_\*）: 3E（分岐を伴わないため）
- テンプレートマッチング:
  - 基本コスト: 3E
  - テンプレート長: ceil(length / 2)E
  - 検索距離: ceil(distance / 10)E
- ユニット操作: 1E 追加

### ユニット存在確認の例

```
; 例1: HULL[3]の存在確認
  UNIT_EXISTS
  0x03        ; HULL(種別0) + index 3
  0x00
  0x00
  TEST_A      ; Aが0かチェック
  JZ no_hull  ; 存在しない場合の処理へ

; 例2: 動的インデックスでのCOMPUTER存在確認
  ; Dレジスタにindexが入っていると仮定
  MOVE_DA     ; A = D
  LOAD_IMM_B  ; B = 0xC0 (COMPUTER種別)
  0xC0
  0x00
  OR_AB       ; A = 0xC0 | index
  MOVE_AB     ; B = A (一時保存)

  UNIT_EXISTS
  ; 第2バイトはBレジスタの値を使用したいが、命令形式上固定値が必要
  0xC0        ; COMPUTER種別 + index 0 (例)
  0x00
  0x00
  TEST_A
  JZ no_computer
```

### エラー処理の例

```
; 存在しないユニットへのアクセス
  UNIT_MEM_READ
  0x89        ; DISASSEMBLER[9] (存在しない)
  0x00
  0x00
  ; Aレジスタには0xFFFFが返される

  LOAD_IMM_B
  0xFF
  0xFF
  CMP_AB
  JE access_error  ; エラー処理へ

; 領域外メモリアクセス
  LOAD_ABS
  0xFF        ; アドレス0xFFFF (最後のバイト)
  0xFF
  0x00
  ; 正常に読み取れる

  LOAD_ABS
  0x00        ; アドレス0x10000 (領域外)
  0x00
  0x01
  ; Aレジスタには0xFFFFが返される
```

### サブルーチン呼び出しの例

```
; メインプログラム
0x00: LOAD_IMM    ; A = 5
0x01: 0x05
0x02: CALL        ; サブルーチンを呼び出し
0x03: 0x10        ; +16バイト先（0x12）へジャンプ
0x04: NOP         ; ここに戻ってくる
; ... メインプログラムの続き

; サブルーチン（0x12から）
0x12: INC_A       ; Aをインクリメント
0x13: RET         ; Cレジスタの値（0x04）に戻る
0x14: 0x00        ; 第2バイト（無視される）
0x15: 0x00        ; 第3バイト（無視される）
```

### スタック操作の例

```
; 複数のレジスタを保存して関数呼び出し
0x00: PUSH_A      ; Aを保存
0x01: PUSH_B      ; Bを保存
0x02: LOAD_IMM    ; A = 10
0x03: 0x0A
0x04: 0x00
0x05: LOAD_IMM_B  ; B = 20
0x06: 0x14
0x07: 0x00
; ... 何かの処理
0x10: POP_B       ; Bを復元
0x11: POP_A       ; Aを復元（LIFO順）
```

### 条件付き移動の例

```
; 最大値を選択（A = max(A, B)）
0x00: CMP_AB      ; AとBを比較
0x01: CMOV_C      ; C=1（A < B）ならBをAにコピー
0x02: 0x01        ; ソース: B
0x03: 0x00        ; 宛先: A
0x04: 0x00
0x05: 0x00
; Aには大きい方の値が格納される
```

### 複数ユニットアクセスの例

```
; 3つのASSEMBLERから空いているものを探す
  LOAD_IMM    ; D = 0（最初のASSEMBLER）
  0x00
  MOV_AD

FIND_FREE:
  ; Dレジスタの値を使ってユニット指定バイトを作成
  MOV_DA      ; D→A
  ADD_AB      ; A = A + 0x40（Bに0x40を事前設定必要）
  MOV_AB      ; 一時保存

  UNIT_MEM_READ ; ASSEMBLER[D]の状態確認
  ; 第2バイトはBレジスタから（0x40 + D）
  0x00        ; アドレス0x00（状態）

  JZ          ; 空いていれば使用
  0x08        ; USE_ITへ

  INC_D       ; 次のASSEMBLERへ
  LOAD_IMM    ; A = 3（ASSEMBLERの総数）
  0x03
  MOV_DA      ; D→A
  XOR_AB      ; A == 3なら0（全て確認済み）
  JZ          ; 全て使用中
  0x10        ; エラー処理へ

  JMP         ; 次を確認
  -0x10       ; FIND_FREEへ戻る

USE_IT:
  ; D番目のASSEMBLERを使用
  ; パラメータ設定と開始は上記の例と同様
```

### 子COMPUTERへのプログラム転送例（レジスタベース版）

```
; 新しく生成されたCOMPUTERにプログラムを転送
; 前提：新COMPUTERのインデックスがDレジスタに格納済み

; まず待機ループを書き込む
  LOAD_IMM    ; A = JMP命令
  0x60
  MOV_AD      ; D = COMPUTER[新index]（例：0xC1）
  MOV_BC      ; C = 0（アドレス）
  UNIT_MEM_WRITE_REG
  0x3C        ; Dレジスタ（ユニット）、Cレジスタ（アドレス）
  0x00

  LOAD_IMM    ; A = -2（自分自身へジャンプ）
  0xFE
  INC_C       ; C = 1
  UNIT_MEM_WRITE_REG
  0x3C        ; D、Cレジスタ使用
  0x00

; メインプログラムを書き込む（アドレス2から）
  LOAD_IMM    ; B = 2（ソースアドレス）
  0x02
  MOV_AB
  LOAD_IMM    ; C = 2（宛先アドレス）
  0x02
  MOV_AC

TRANSFER_LOOP:
  ; 自分のメモリから読み出し
  LOAD_REG    ; A = Memory[B]
  0x01        ; Bレジスタ

  ; 子COMPUTERに書き込み（D=ユニット、C=アドレス）
  UNIT_MEM_WRITE_REG
  0x3C        ; Dレジスタ、Cレジスタ
  0x00

  INC_B       ; ソースポインタ++
  INC_C       ; 宛先アドレス++

  ; 転送完了判定（例：100バイト転送）
  MOV_CB      ; B→C を一時保存
  LOAD_IMM    ; A = 100
  0x64
  CMP_AB      ; B - 100
  MOV_BC      ; C→B を復元
  JLE         ; B <= 100ならループ継続
  -0x10       ; TRANSFER_LOOPへ

; 最後に待機ループを解除
  LOAD_IMM    ; A = NOP
  0x00
  MOV_BC      ; C = 0
  UNIT_MEM_WRITE_REG
  0x3C
  0x00

; 書き換え許可を拒否に変更
  LOAD_IMM    ; A = 0（拒否）
  0x00
  LOAD_IMM    ; C = 0xFF
  0xFF
  MOV_AC
  UNIT_MEM_WRITE_REG
  0x3C
  0x00
```

### 配列処理の例（新命令使用）

```
; 配列の合計を計算（配列は0x80から開始、長さ16）
  LOAD_IMM    ; B = 0x80（配列開始）
  0x80
  MOV_AB
  LOAD_IMM    ; C = 0（合計）
  0x00
  MOV_AC
  LOAD_IMM    ; D = 16（カウンタ）
  0x10
  MOV_AD

ARRAY_LOOP:
  LOAD_REG    ; A = Memory[B]（配列要素）
  0x01        ; Bレジスタ

  ADD_AB      ; A = A + B（※Bは一時的に合計として使用）
  MOV_CB      ; 合計を保存
  INC_B       ; 配列ポインタ++
  DEC_D       ; カウンタ--

  MOV_DA      ; D→A
  JNZ         ; カウンタ != 0ならループ
  -0x08       ; ARRAY_LOOPへ

  ; 結果はCレジスタに格納
```

### スタックポインタアクセス

```
; 現在のスタックポインタを取得
0x00: MOV_SP      ; A = 現在のSP値
; Aレジスタにスタックポインタが入る

; スタックポインタを設定
0x01: LOAD_IMM    ; A = 0xF000
0x02: 0x00
0x03: 0xF0
0x04: SET_SP      ; SP = 0xF000
```

### 間接アドレッシングの例

```
; ポインタ配列を使った処理
; メモリ0xF0にデータのアドレスが格納されている

  LOAD_IND_REG ; A = Memory[Memory[0xF0]]
  0xF0         ; 0xF0の内容が指すアドレスから読み込み

  ; ポインタ経由で書き込み
  LOAD_IMM     ; A = 書き込む値
  0x42
  STORE_IND_REG ; Memory[Memory[0xF1]] = A
  0xF1         ; 0xF1の内容が指すアドレスへ書き込み
```

### 自己複製プログラムの例

```
; テンプレートマッチングを使用した自己複製プログラム
; 前提: HULLに固定されたASSEMBLERがある

; プログラム開始位置マーカー
START:
  NOP1 NOP0 NOP1 NOP0    ; テンプレート: 1010
  LOAD_IMM               ; A = プログラムサイズ
  0x40                   ; 64バイト

; 複数ASSEMBLERがある場合、最初のものを選択
  LOAD_IMM               ; D = 0（最初のASSEMBLER）
  0x00
  MOV_AD                 ; A→D

; ASSEMBLERにCOMPUTER生成を指示
  ; まず生産パラメータを設定
  LOAD_IMM               ; A = COMPUTER種別コード
  0xC0
  UNIT_MEM_WRITE         ; ASSEMBLER[0]のメモリに書き込み
  0x40                   ; 種別4、インデックス0
  0x10                   ; アドレス0x10（生産ユニット種別）

  LOAD_IMM               ; A = 動作周波数
  0x01                   ; 1命令/tick
  UNIT_MEM_WRITE
  0x40
  0x11                   ; アドレス0x11（パラメータ1）

  LOAD_IMM               ; A = メモリサイズ
  0x80                   ; 128バイト
  UNIT_MEM_WRITE
  0x40
  0x12                   ; アドレス0x12（パラメータ2）

  ; 生産開始
  LOAD_IMM               ; A = 1（開始フラグ）
  0x01
  UNIT_MEM_WRITE
  0x40
  0x1F                   ; アドレス0x1F（生産開始フラグ）

; 生成完了待機ループ
WAIT_LOOP:
  NOP0 NOP1 NOP0 NOP1    ; テンプレート: 0101
  UNIT_MEM_READ          ; ASSEMBLER[0]の状態確認
  0x40                   ; 種別4、インデックス0
  0x00                   ; アドレス0x00（状態）
  ; 状態の下位bitが0なら待機中
  JZ                     ; 完了なら次へ
  0x08                   ; +8バイトジャンプ（COPY_STARTへ）

  ; ループ継続（WAIT_LOOPへ戻る）
  SEARCH_B               ; 後方検索
  NOP1 NOP0 NOP1 NOP0    ; 補完パターン: 1010を探す
  JMP_IND                ; 見つかった位置へジャンプ
  0x01                   ; Bレジスタ指定
  0x00                   ; 未使用

; コピー処理開始
COPY_START:
  NOP1 NOP1 NOP0 NOP0    ; テンプレート: 1100
  LOAD_IMM               ; B = 0（コピー元アドレス）
  0x00
  LOAD_IMM               ; C = プログラムサイズ
  0x40

; メモリコピーループ
COPY_LOOP:
  NOP0 NOP1 NOP1 NOP0    ; テンプレート: 0110
  LOAD_IND               ; A = Memory[B]
  0x00                   ; オフセット0
  UNIT_CMD               ; 新COMPUTERメモリ書き込み
  0xC0                   ; COMPUTER種別
  0x02                   ; メモリ書き込みコマンド
  INC_A                  ; B++（次のアドレス）
  MOV_AB                 ; A→B
  DEC_C                  ; カウンタ減算
  JNZ                    ; まだ残りがあれば
  0x08                   ; +8バイト先へ（次の検索命令をスキップ）

  ; ループ継続（COPY_LOOPへ戻る）
  SEARCH_B               ; 後方検索
  NOP1 NOP0 NOP0 NOP1    ; 補完パターン: 1001を探す
  JMP_IND                ; 見つかった位置へジャンプ
  0x01                   ; Bレジスタ指定
  0x00                   ; 未使用

; 新COMPUTERを分離
  UNIT_CMD               ; HULLへコマンド
  0x00                   ; HULL種別
  0x03                   ; 分離コマンド
```

### スタック操作

- スタックはメモリ最後尾（0xFFFF）から下方向に成長
- 16bit値を扱うため、2バイト単位で操作
- スタックオーバーフロー/アンダーフローはエラー処理されず、循環する

### メモリ管理の注意事項

#### スタック保護機構の不在

現在の仕様では、スタック領域と他のメモリ領域を分離する明示的な保護機構は存在しません。プログラマは以下の点に注意する必要があります：

- スタックがプログラムやデータ領域を上書きする可能性
- プログラムがスタック領域を破壊する可能性
- メモリ衝突による予測不可能な動作

#### 推奨メモリレイアウト

メモリ衝突を避けるため、以下のようなメモリレイアウトを推奨します：

```
0x0000-0x3FFF: プログラムコード領域（16KB）
0x4000-0xDFFF: データ/ヒープ領域（40KB）
0xE000-0xFFFF: スタック領域（8KB）
```

#### プログラミングによる対策

1. **初期化時のスタック位置設定**

   ```assembly
   ; プログラム先頭でスタック領域を確保
   LOAD_IMM    ; A = 0xE000 (スタック開始位置)
   0x00
   0xE0
   SET_SP      ; SP = 0xE000
   ```

2. **境界チェックの実装**
   ```assembly
   ; スタックプッシュ前にチェック
   MOV_SP      ; A = 現在のSP
   LOAD_IMM    ; B = スタック下限
   0x00
   0xD0
   MOV_AB
   CMP_AB      ; SP < 下限？
   JC STACK_OVERFLOW_HANDLER
   ```

詳細な実装例については、`agent-code/v3.0.0/memory-management-best-practices.md`を参照してください。

### COMPUTERの生成について

- COMPUTERは唯一自律動作するユニットである。生成が完了した次のtickから動作を始めるが、生成直後はプログラムカウンタ、ワーキングレジスタ、フラグ、メモリの全ての値は0である
  - その状態（NOP命令のみがメモリに入っている）でCOMPUTERが動作しても何も行わない（メモリの最後までNOP命令を実行したら、またメモリの先頭へ戻って実行）
  - 生成したCOMPUTERに意味のある仕事を行わせたい場合、先頭にループを書き込んでおき、そのループを実行している間にメモリに内容を書き込み、最後にその先頭ループを削除（NOPで上書き）する、という手順でメモリの書き込みを行うことができる

### 外部ユニットとのメモリマップドI/O

#### 基本概念

- 全てのユニットは固有のメモリ領域を持つ
- 接続されたユニットのメモリは、UNIT_MEM_READ/UNIT_MEM_WRITE命令でアクセス
- 複数引数を要する操作は、引数を全て書き込んでから実行フラグを設定
- 存在しないユニットへのアクセスや領域外アクセス時は0xFFFFを返す

#### アクセス方式

```
; ユニット指定（第2バイト）
; 上位4bit: ユニット種別（0x0=HULL, 0x4=ASSEMBLER, 0x8=DISASSEMBLER, 0xC=COMPUTER）
; 下位4bit: 同種ユニットのインデックス（0-15）

; 例：3番目のASSEMBLER（種別0x4、インデックス3）
0x43  ; = 0x40 | 0x03
```

#### エラー処理

```
; ユニット存在確認
UNIT_EXISTS
0x45        ; ASSEMBLER[5]の確認
0x00
0x00
TEST_A      ; Aレジスタが0かチェック
JZ unit_not_exists

; メモリアクセス時のエラー
UNIT_MEM_READ
0x45        ; 存在しないユニット
0x00
0x00
LOAD_IMM_B
0xFF
0xFF
CMP_AB      ; A == 0xFFFFかチェック
JE error_handler
```

#### 利点

- **アトミック性**: 全パラメータ設定後に実行
- **統一性**: 全ユニットが同じインターフェース
- **拡張性**: 新ユニット追加が容易
- **エラー検出**: 存在確認とエラー値により安全な操作が可能

### メモリ書き込み機構（暫定案B採用）

- COMPUTERは「外部からのメモリ書き換え許可/拒否」プロパティを持つ
- 生成時は「許可」状態で生成される
- 親COMPUTERは生成した子COMPUTERのメモリに書き込み可能（UNIT_MEM_WRITE使用）
- 書き込み完了後、子COMPUTERの書き換え許可を「拒否」に変更することを推奨

### 命令実行とメモリ破損への耐性

#### 命令境界のずれへの対応

- 可変長命令により、命令境界のずれは最悪でも3バイト以内に正常化
- 未定義オペコードはNOP扱いとして実行を継続

#### メモリ内容変化への対応

- NOP0（0x00）とNOP1（0x01）により、テンプレート機能を維持
- ゼロクリアされた領域はNOP0として安全に実行可能
- 補完パターンマッチングにより、コードの位置が変わっても動作継続可能

#### 進化の可能性

- ビット反転により別の命令に変化する可能性
- パターンの変化により、ジャンプ先が変更
- 未定義領域の存在により、将来の命令拡張の余地を確保

## TODO項目

### 解決済み項目

- ✅ ワーキングレジスタ: A, B, C, Dの4本（各16bit）
- ✅ フラグ: ゼロフラグとキャリーフラグの2種類
- ✅ メモリ: 各8bitアドレス、最大65,536バイト（64KB）
- ✅ 命令セット: 可変長命令（1-5バイト）、完全定義済み
- ✅ テンプレートマッチング: NOP0/NOP1による補完パターン方式
- ✅ エネルギー消費: 命令種別ごとに定義済み
- ✅ メモリ書き込み機構: 暫定案B採用（外部書き換え許可/拒否プロパティ）
- ✅ アドレッシングモード: 相対・絶対・テンプレート・レジスタベース・間接の5方式
- ✅ 複数ユニット識別: Dレジスタによるインデックス方式
- ✅ 動的メモリアクセス: レジスタベース・間接アドレッシング命令追加
- ✅ 比較演算: SUB_AB、CMP_AB、条件分岐命令（JC/JNC/JG/JLE）追加
- ✅ 16bitアーキテクチャ: PC、レジスタ、アドレス空間すべて16bit化完了

### 未解決項目

#### 1. 外部ユニット連携

- TODO: ユニット種別コードの詳細定義（現在は例示のみ）
- ✅ HULLのdetach操作メモリマップ定義（0x06-0x08に定義済み）
- TODO: アクション予約タイミング（即座実行 or 次tick予約）

#### 2. メモリ書き込み機構の詳細

- TODO: 外部書き換え許可状態の切り替え方法
- TODO: 複数COMPUTERからの同時書き込み競合処理
- TODO: 部分書き込み時の一貫性保証

#### 3. パフォーマンス関連

- TODO: テンプレートマッチングの最大検索距離のデフォルト値（16bit空間での適切な値）
- TODO: 動作周波数の実用的な上限値（現在はコストで制限）
