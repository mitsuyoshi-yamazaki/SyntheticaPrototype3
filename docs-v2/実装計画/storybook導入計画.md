# Storybook導入計画

## 1. 背景と目的

### 1.1 現状の課題

- UIコンポーネントとゲームオブジェクトの描画確認が、アプリケーション全体を起動しないと確認できない
- 個別のオブジェクト（HULL、COMPUTER、ASSEMBLER等）の視覚的な確認が困難
- デザイン仕様（docs/design.md）との整合性確認が手間

### 1.2 導入目的

- UIコンポーネントの独立したカタログ化
- ゲームオブジェクトの個別描画確認
- デザイン仕様との視覚的な整合性確認の効率化
- 開発時の迅速なフィードバックループの実現

## 2. 代替手法の検討

### 2.1 考えられる代替案

#### 案1: 専用のデバッグページを作成

- **メリット**
  - 実装がシンプル
  - 追加の依存関係が不要
  - PixiJSの動作確認が確実
- **デメリット**
  - カタログ化の仕組みを自前で実装する必要がある
  - インタラクティブなプロパティ変更が困難
  - ドキュメント化機能がない

#### 案2: Jest + スナップショットテスト

- **メリット**
  - テストフレームワークとして既に導入済み
  - 自動回帰テストが可能
- **デメリット**
  - 視覚的な確認が困難
  - PixiJSのCanvas描画のテストが複雑
  - リアルタイムでの確認ができない

#### 案3: Playwright等のE2Eテストツール

- **メリット**
  - 実際のブラウザ環境での動作確認
  - スクリーンショット比較が可能
- **デメリット**
  - セットアップが複雑
  - 開発時の即座のフィードバックには不向き
  - 重い

### 2.2 Storybookを選択する理由

- コンポーネントカタログとして業界標準
- インタラクティブなプロパティ調整が可能（Controls addon）
- ドキュメント生成機能
- アドオンエコシステムが充実
- 開発コミュニティが活発

## 3. PixiJS描画のStorybook対応検討

### 3.1 技術的な実現可能性

#### PixiJSとStorybookの統合

```typescript
// 想定される実装例
export const HullObject: Story = {
  render: () => {
    const containerRef = useRef<HTMLDivElement>(null)

    useEffect(() => {
      const app = new PIXI.Application()
      // PixiJSの初期化とオブジェクト描画

      return () => {
        app.destroy()
      }
    }, [])

    return <div ref={containerRef} />
  }
}
```

#### 確認できる項目

- 各ゲームオブジェクト（HULL、COMPUTER、ASSEMBLER、ENERGY）の個別描画
- 色、サイズ、状態（active/inactive）の変更
- アニメーション効果
- 複数オブジェクトの組み合わせ

### 3.2 制限事項と対応方針

#### WebGLコンテキストの制限

- **制限**: ブラウザのWebGLコンテキスト数には上限がある（通常8〜16個）
- **対応**: **同時に表示するCanvasは1つのみとする**
  - 各ストーリーは単独で表示
  - ストーリー切り替え時に前のCanvasは破棄
  - この制約は描画確認の用途では問題ない

#### パフォーマンス測定

- **制限**: Storybook環境でのパフォーマンスは実環境と異なる
- **対応**: **パフォーマンス計測は要件外のため問題なし**
  - 描画の正確性確認が主目的
  - パフォーマンス測定が必要な場合は実環境で実施

#### ゲームループのシミュレーション

- **制限**: 通常のゲームループ（tick処理）の再現が複雑
- **対応**: **静的な状態表示のみで十分**
  - 特定の状態（active/inactive、HP満タン/減少時など）での描画確認
  - アニメーションが必要な場合は個別に実装
  - 時間経過のシミュレーションは不要

## 4. 実装計画

### 4.1 導入手順

1. **Storybookのインストール**

   ```bash
   npx storybook@latest init
   ```

2. **必要なアドオンの追加**
   - @storybook/addon-controls: プロパティの動的変更
   - @storybook/addon-docs: ドキュメント生成
   - @storybook/addon-viewport: レスポンシブ確認

3. **PixiJS対応のカスタムデコレータ作成**
   - Canvas要素の適切な管理
   - メモリリークの防止

4. **ストーリーファイルの作成**
   - UIコンポーネント用: `*.stories.tsx`
   - ゲームオブジェクト用: `GameObjects.stories.tsx`

### 4.2 ディレクトリ構造

```
.storybook/
├── main.ts           # Storybook設定
├── preview.ts        # グローバル設定
└── decorators/       # カスタムデコレータ
    └── pixi.tsx      # PixiJS用デコレータ

src/
├── components/
│   └── *.stories.tsx # UIコンポーネントのストーリー
└── stories/
    ├── GameObjects.stories.tsx  # ゲームオブジェクト
    └── Scenes.stories.tsx       # ゲームシーン
```

## 5. 起動方法

### 5.1 開発時

```bash
# Storybookの起動
yarn storybook

# 通常のアプリケーションと並行して起動
yarn dev         # Next.js (localhost:3000)
yarn storybook   # Storybook (localhost:6006)
```

### 5.2 ビルド

```bash
# 静的サイトとしてビルド
yarn build-storybook

# 出力先: storybook-static/
```

### 5.3 CI/CD統合

- GitHub Pagesへの自動デプロイ
- Chromatic等のビジュアルレグレッションテストツールとの連携

## 6. 懸念事項と対策

### 6.1 パフォーマンス

**懸念**: 複数のPixiJSインスタンスが同時に動作する場合のパフォーマンス
**対策**:

- 各ストーリーでのPixiJSインスタンスの適切な破棄
- WebGLコンテキストの共有を検討
- 必要に応じてCanvasフォールバック

### 6.2 メンテナンスコスト

**懸念**: ストーリーファイルの保守負担
**対策**:

- コンポーネントとストーリーを同じディレクトリに配置
- 自動生成スクリプトの検討
- 重要なコンポーネントに絞って作成

### 6.3 ビルドサイズ

**懸念**: Storybookの依存関係によるビルドサイズ増加
**対策**:

- Storybookは開発依存関係として管理
- 本番ビルドには影響しない
- 必要に応じて別リポジトリ化を検討

### 6.4 型安全性

**懸念**: TypeScriptとの統合
**対策**:

- Storybook 7.xはTypeScriptを完全サポート
- 型定義ファイルの適切な配置
- strictモードでの動作確認

## 7. 期待される効果

### 7.1 開発効率の向上

- 個別コンポーネントの迅速な確認
- デザイナーとの円滑なコミュニケーション
- バグの早期発見

### 7.2 ドキュメント化

- コンポーネントカタログの自動生成
- 使用例の明確化
- 新規参加者のオンボーディング改善

### 7.3 品質向上

- デザイン仕様との整合性確認が容易
- エッジケースのテストが簡単
- ビジュアルレグレッションテストの基盤

## 8. 実装優先順位

1. **Phase 1: 基本セットアップ**（1日）
   - Storybookのインストール
   - 基本設定
   - サンプルストーリー作成

2. **Phase 2: PixiJS統合**（2日）
   - カスタムデコレータ作成
   - ゲームオブジェクトのストーリー作成
   - メモリ管理の実装

3. **Phase 3: 全コンポーネント対応**（3日）
   - 既存UIコンポーネントのストーリー化
   - ドキュメント作成
   - CI/CD統合

## 9. 判断基準

### 導入すべき場合

- 複数人での開発
- デザイン仕様の頻繁な変更
- UIコンポーネントの再利用性を重視
- 長期的なメンテナンスを想定

### 導入を見送るべき場合

- プロトタイプ段階で頻繁に構造が変わる
- 単独開発で視覚確認の需要が低い
- リリース期限が迫っている

## 10. まとめ

Storybookの導入により、UIコンポーネントとゲームオブジェクトの描画確認が効率化され、開発速度と品質の向上が期待できる。PixiJSとの統合には技術的な課題があるものの、適切な実装により解決可能である。

プロジェクトの現段階（プロトタイプ開発）を考慮すると、基本的なセットアップから始めて、必要に応じて段階的に拡張していくアプローチが推奨される。
