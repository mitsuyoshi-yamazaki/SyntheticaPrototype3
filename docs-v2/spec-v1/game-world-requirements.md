## このファイルについて

- 本ファイルはゲームの要件と仕様について記載している
- **本ファイルは記載途中である。簡易な実装のバージョンを game-world-requirement-minimum.md に記載している**

## Claudeへの指示

- ゲームの要件と仕様を更新した際は本ファイルの内容も追従させること

## ゲーム要件

- このゲームは、プレイヤーが作成したエージェントを環境中に放って自律行動するのを観察するMMOゲームである
  - このゲームの目的は、オープンエンドな進化を、①十分に一貫した自由度の高いシミュレーション系のうえで、②人間に競争させることでオープンエンド性を付与する ことで実現するものである（※ 人間が競争する際に発揮する創造性はオープンエンドであるという仮定のもと進める）
- エージェントは全て自律的に動作し、環境中の資源を回収・代謝して自己を拡張・修復・複製する
- エージェントの身体は資源回収、移動、アセンブリ、情報処理など複数の種類のユニットを組み合わせて成り立つ
- プレイヤーはこのエージェントの身体部分を定義するとともに、頭脳ユニットで実行するソフトウェアを作成することでエージェントを作成する
- このような仕様のシミュレーションにより、地球上に存在するものも存在しないものも含めて、任意の生態を持つエージェントを作成・繁殖できる場を提供することを目的とする

## ゲーム仕様

### 世界

- 世界は上下左右がループした二次元トーラス形状をとる
- ゲームの空間（正確には平面であるが、空間と呼称する）は正方形のセルに分割されており、空間に作用する現象（現状では熱のみ）は個々のセルに対して作用する
  - 一方でゲームオブジェクトの移動はセルとは無関係に、連続値の座標を取る
- ゲームの時間は離散的である。各tickにゲームオブジェクト物理演算とユニットの動作処理が行われ、その結果が次tickに反映される

### "実際のゲーム世界"

_"実際のゲーム世界"のセクションはアプリケーションの仕様には影響しない、仕様策定の際のフレーバー背景である_

- このゲームは、ゲーム内の物理法則として、質量の保存則やエントロピーの法則をもつ
- このゲームの仕様としてそれらの法則に例外があるように見える（エネルギーソースからエネルギーが無限に湧き出す、熱が時間経過で減っていく、等）のは、アプリケーション上に表現されるこのゲームの空間は、"実際のゲーム世界"の"高さ"方向の一断面に過ぎないためである
  - このゲームの空間は、"実際のゲーム世界"の中での局所的にエントロピーが減少する一部分を切り取ったものである
  - その解釈に基づくと、エネルギーソースは"実際のゲーム世界"からのエネルギー供給、放熱は"実際のゲーム世界"の高さ方向へ熱が拡散していく現象である、と解釈される
  - これは現実世界における以下の現象との対応で理解できる
    - このゲームの空間：地球（太陽から供給されるエネルギーによる局所的なエントロピーの減少）
    - エネルギーソース：太陽
    - 放熱：宇宙空間への放熱

### ゲームオブジェクト

- ゲーム世界上に存在する物体のことをゲームオブジェクトと呼称する
- ゲームオブジェクトは以下のプロパティをもつ
  - 位置
    - 位置は（離散的なグリッド上に置かれるのではなく）連続的数値で表される
  - 大きさ、形状
  - 速度
    - 速度は前tickにそのゲームオブジェクトに加わった加速度により増減する
  - 重量
    - 重量はゲームオブジェクトにかかった力がどれだけの加速度を生むかに影響する
  - 構成物質
- 仕様
  - 衝突
    - 複数のゲームオブジェクトが同時に同じ空間の一点に存在することは禁止したいが、計算処理を容易にするため、完全に禁止はせずに以下の仕様で実装する
      - 重なった複数の物体は共通重心から離れる方向へ力を受ける（ことにより、物体の重なりを時間経過で解消する）
  - 隣接
    - ふたつのオブジェクトが"隣接"している状態とは以下のどれかの状態である
      - 双方がユニットであり、接続している状態
      - ふたつのオブジェクトが"隣接距離"以下の間隔で隣り合っている状態
        - 両方がHULLの中にいる場合は常に隣接状態
        - HULLとそのHULLの内容物は常に隣接状態

### 熱

- 空間のセルは熱の値をもち、熱はゲームオブジェクトに影響を与える
- 挙動
  - 熱の値はエネルギーの消費等、世界とゲームオブジェクトのさまざまな活動によりセルに加算される
    - これはこの世界におけるエントロピーを表現している
  - 熱の値は隣接セルの間で均衡するように移動する。この計算時は熱の総量は増減しない（この計算後、後述の放熱の計算により熱の総量は減少する）
  - セルの熱の値は時間経過で減ってゆく
    - これは放熱を表現している
- 後述の資源やユニットはそれ自体は熱の値を持たず、配置されているセルの熱の値により熱の影響を受ける
  - 資源やユニットは大きさをもつので複数のセルにまたがる位置に存在することがあるが、受ける熱の影響は、ユニットの座標が含まれるセルの熱の値である
    - この仕様は基本的にはゲーム世界の法則の一貫性を崩すが、プロトタイプであるので実装の簡便さと法則の一貫性の間をとってこの仕様とする

### 資源

- 資源はゲームオブジェクトである
- 原則：世界に存在する資源の総量は常に一定である（質量の保存）
  - 細則：ある物体を構成、分解しても、資源の総量は変わらない
  - 例外：
    - プレイヤーが新たなエージェントを世界に投入する際には、そのエージェントの構成物質分の資源が世界に追加される。この問題は将来的には解消させる
    - エネルギーは質量保存の原則の例外である
      - エネルギーは毎tick新たに生成される
      - エネルギーは消費時に消滅し、他の資源に変換されない
      - そのため、エネルギーを除いた3種類の資源（Mineral、Organic、Chemical）のみが質量保存の原則に従う
- 資源は粒子の形状をとる
- 資源の量は0以上の整数であり、小数をとらない
- 種別
  - 資源の種類は以下の4種類である
    - mineral
      - 1単位あたりの質量：10
    - organic
      - 1単位あたりの質量：1
    - chemical
      - 1単位あたりの質量：3
    - energy（後述のエネルギー）
      - 1単位あたりの質量：0（質量を持たない）

#### エネルギー

- エネルギーは資源の一種であるが、質量保存の原則の例外である
- エネルギーはエネルギーソースから、ソースごとに定められたエネルギー算出量に応じて、毎tick生成される（世界に新たに追加される）
- 資源の分解や合成、エージェントの移動やCOMPUTERの計算処理など、全ての活動はエネルギーを消費する。消費されたエネルギーは完全に消滅するが、消費されたエネルギー量に比例した熱をその場所に加える
- この仕様により、エネルギーは世界の活動を駆動する外部エネルギー源としての役割を果たす

#### 物質

- 資源が合成されて生成される物質には以下の3種類がある
  - ユニット（後述）
  - ユニット断片
    - 破壊され、機能を失ったユニット。マテリアルと同じ（ゲーム演出上の見た目のみが異なる）
  - マテリアル
    - 1種類以上の資源が、物理現象もしくはASSEMBLERにより合成されて生成された物体
    - マテリアルから資源を回収するには、物理現象により分解されたところを利用するか、DISASSEMBLERにより分解する必要がある

#### 物質の合成と分解

- 近接する資源やマテリアルが一定の条件を満たすと合成されて別のマテリアルに変化する（ユニットが自然に合成されることはない）
- また、マテリアルやユニットが一定の条件を満たすと分解して資源が分離し、ユニット断片、別のマテリアル、資源などに変化する
- 物質の合成と分解の前後で、エネルギー以外の資源の総量が変化することはない
- TBD: 合成と分解の条件を記載する
  - idea: 隣接するとくっつく物質など
  - idea: 加速度で分解する
  - idea: 熱で合成 / 分解する

### エージェント

- 「エージェント」とは、相互に結合したユニットの集まりを、人間のために便宜上そう呼んでいるだけであり、ゲームの実装上そのような単位の実装が存在するわけではない
  - ゲーム世界上では、それぞれのユニットが自律して動作し、周囲のユニットや環境と相互作用を行っているだけである

### ユニット

- ユニットはゲームオブジェクトである
- 仕様：
  - ユニット生成時に固定される性質と、生成後に再設定可能な性質がある
  - ユニット生成
    - 全てのユニットはASSEMBLERにより、そのユニットを構成するのに必要な資源と、エネルギーを使って構築される
    - ユニット構築に必要な資源とエネルギーの量は、ユニットの種別ごとに異なる。また、同じユニットでも、異なる資源配分で構築されたものは異なるパラメータを持つ
      - この仕様は「生産仕様」の項に定義される
      - あるユニットの生産に必要な資源の量（recipe）は、それぞれの資源の頭文字 + 資源量で M1,O2,C3,E4 （Mineral:1, Organic:2, Chemical:3, Energy:4）のように表す
        - ユニット生成時にエネルギーは全て消費されるので、上の例で実際にユニットを構成する総資源量は M1,O2,C3,E0 である。この、"完全である"（= ダメージを負っていない）状態のユニットを構成する総資源量のことを、「ユニット最大資源量（max composition）」と言い、現在の（= 負ったダメージを含む）ユニットの資源量を「現在のユニット資源量（current composition）」と言う
  - ユニット分解
    - ユニットはDISASSEMBLERに分解される、または環境ダメージにより構成資源を剥ぎ取られることでダメージを負う
      - 軽微なダメージはASSEMBLERにより、失った資源とエネルギーを費やすことで修復が可能である
      - 一定以上の構成要素を失ったユニットはユニットとしての機能を喪失し、"分解された"状態となる
      - ユニットが分解されると資源へと変化する。このとき、資源の総量は分解前のユニットの構成資源量と変わらない
    - あるユニットがどのように分解されるかは「分解仕様」の項に定義される
  - ユニットはゲームオブジェクトに直接作用しない、ソフトウェアの実行に関わる回路としての性質をもつ（回路仕様）
  - ユニットはHULLの外側または内側に固定することができる。HULLも例外ではない
    - 固定されたユニットとHULLは回路が接続している状態となる
  - エージェントの身体仕様はユニットの結合状況で表現される
    - ユニットの結合状況は木構造で表現される
- 回路仕様：
  - 回路的に接続しているユニットへはソフトウェアから情報アクセス・指令ができる（物理的に接続していても回路的には接続していない状態もある）
  - COMPUTERが実行するソフトウェアから特定のユニットへアクセスするためのラベルをつけられる
  - ユニットは、回路で接続しているCOMPUTERからアクセスするためのAPIをもつ
  - 基本的な構想として、ユニットが何かの行動を起こそうとして失敗する場合、ソフトウェア的なエラーを返すのではなく、実行はするが意図した結果が得られない、という現象として実現する
- ユニットには以下の種別がある
  - HULL
  - ASSEMBLER
  - DISASSEMBLER
  - CONNECTOR
  - CHANNEL
  - COMPUTER
  - SENSOR
  - MOVER

#### HULL

- 概要：
  - ゲーム世界の一角を区切ることで、エージェントの身体を形作る。エージェントを細胞に例えるとHULLは細胞膜である
- 仕様：
  - HULLは容量をもち、他のユニットや資源を格納できる
    - HULLの内部に物質が配置される際、HULLの容量を超える場合はその物質はHULLの外に配置される
  - HULLの中身は広さのない空間（内容物全てが"隣接"しており、HULLに対する相対速度は常に0の状態）である
    - この性質により、HULLの内部に配置されたASSEMBLERやDISASSEMBLERはHULLとHULLの内部に格納されたユニット全てに対して操作が可能である
    - ゲーム的な観点から、見た目上は広さがあり、それぞれの内容物が重ならずに存在している見た目（細胞の模式図のような）をとる
  - HULLは入れ子にできる
  - HULLには外側と内側がある
- 回路仕様：
  - HULLに接続しているユニットを回路的に接続する
    - accessibilityでアクセスが禁止されている方向へは接続されない
- 生成仕様
  - 容積が固定のHULL:
    - `M0,O3,C1,E5 * floor((容積 + 1) * 1.05)`
      - ※ 容積は0以上の整数
  - 生成後に容積を増やせるHULL:
    - `M0,O5,C2,E8 * floor((容積 + 1) * 1.1)`
      - ※ 容積は0以上の整数
- 分解仕様：
  - HULLを構成する `ceil(最大Organic量 / 2)` 以上のOrganic, もしくは `ceil(最大Chemical量 / 3)` 以上のChemicalが剥ぎ取られると分解する
  - HULLユニットが分解するとdestroyed HULLに変化する。HULLとの差異は以下
    - accessibilityが「双方向のアクセスが可能」状態に固定される
    - 修理されなくなる（ASSEMBLERに修理を指示しても何も起きなくなる）
    - HULLに固定されていたユニットは固定されたまま
    - HULLに格納されていた、固定されていないユニットや資源、マテリアル等は放出される
- API：
  - recipe
    - readonly
    - このユニットの生成仕様
  - max composition
    - readonly
    - ユニット最大資源量
  - current composition
    - readonly
    - 現在のユニット資源量
  - damage
    - readonly
    - そのユニットを構成する資源の量からどれだけの資源量を失っているかを表す
    - `max composition - damage = current composition` は常に成り立つ
  - capacity
    - readonly
    - HULLの容量
  - accessibility
    - 生成時に定義。readonly
    - 回路を通じたアクセスが行えるかどうかを表す。以下のうちのひとつ
      - 外側から内側へのアクセスのみ可能
      - 内側から外側へのアクセスのみ可能
      - 双方向のアクセスが可能
      - アクセスはできない
  - adjacent objects inside
    - HULLの内側に格納されているオブジェクトの一覧
  - adjacent objects outside
    - HULLの外側に"隣接"しているオブジェクトの一覧

#### ASSEMBLER

- 概要：
  - recipeで指定したユニットの生成、ユニットの修復、マテリアルの合成を行う
  - ASSEMBLER生成時にrecipeを指定する単一目的のASSEMBLERと、assemble時にrecipeを指定できる万能ASSEMBLERの2種類がある
- 仕様：
  - ユニットの生成
    - 指定のrecipeのユニットを生成する
  - ユニットの修復
    - 指定のユニットの修理を行う。修理とは、そのユニットのダメージを、ダメージにより不足した資源とエネルギーを使って修復することである
    - 1資源単位を修理するのに必要なエネルギー量は、ユニットレシピに依存して変わる
  - マテリアルの合成
    - 指定のrecipeのマテリアルを生成する
  - 生成、修理、合成の順序
    - 原料の回収
      - 隣接する資源からrecipeに指定された原料を、ASSEMBLER内の原料格納スペースに回収する
      - 回収速度は `ceil(2 * 格納スペース容量 ^ 0.5)` である
    - 生成物の設置
      - 指定のマテリアルを合成する
      - 合成にはマテリアルの種別ごとに時間がかかる
      - 原材料は隣接する資源とエネルギーを用いる
      - 合成したマテリアルはASSEMBLERと同じ空間へ配置する
  - 制約
    - ASSEMBLERは原料格納スペースをもち、その格納スペースには容量があるため、容量を超えるrecipeは合成できない
- 回路仕様：
  - なし
- 生成仕様：
  - 単一目的ASSEMBLER：
    - `M5,O40,C3,E100 + M0,O4,C1,E4 * floor(原料格納スペース容積 * 0.1)`
    - 原料格納スペース容量：recipeの原料の総量と等しい
    - MEMO: 自身を合成対象とする単一目的ASSEMBLERは作成可能であり、最小の自己複製子であるが、複製以外一切の活動ができない
      - recipe: `M5,O632,C151,E692`
  - 万能ASSEMBLER：
    - `M60,O200,C30,E400 + M0,O4,C1,E4 * floor(原料格納スペース容積 * 0.1)`
    - 原料格納スペース容量はユニット生成時に指定する
    - MEMO: 自身を複製可能な万能ASSEMBLERの原料格納スペース容量は最低6900以上の容量が必要である
      - 最小構成recipe（容量：6900）： `M60,O2960,C720,E3160`
- 分解仕様：
  - ASSEMBLERを構成する `ceil(最大Mineral量 / 20)` 以上のMineral, もしくは `ceil(最大Organic量 / 6)` 以上のOrganic, もしくは `ceil(最大Chemical量 / 3)` 以上のChemicalが剥ぎ取られると分解する
  - ASSEMBLERユニットが分解するとdestroyed ASSEMBLERに変化する。ユニットの生成、ユニットの修復、マテリアルの合成は動作しなくなる。格納されていた原料は全て放出される
- API：
  - recipe
    - readonly
    - このユニットの生成仕様
  - max composition
    - readonly
    - ユニット最大資源量
  - current composition
    - readonly
    - 現在のユニット資源量
  - damage
    - readonly
    - そのユニットを構成する資源の量からどれだけの資源量を失っているかを表す
    - `max composition - damage = current composition` は常に成り立つ
  - capacity
    - readonly
    - 原料格納スペースの容量
  - is running
    - `True` で原料のある限りassembleを継続する
      - `True` に設定した際は自動的にis releasing ingredientsが `False` になる
    - `False` で停止
  - is releasing ingredients
    - `True` 格納している原料を放出する
      - 放出速度は回収速度と同じ
      - `True` に設定した際は自動的にis runningが `False` になる
    - `False` 格納している原料はそのまま
  - assemble recipe
    - 単一目的ASSEMBLERの場合はreadonly
    - 万能ASSEMBLERの場合は再設定可能
    - 修理のrecipeである場合は修理対象の情報がrecipeに含まれており、ユニット生成のrecipeである場合はそのユニットの生成時の設定と生成後設置場所の情報がrecipeに含まれる
  - stored resources
    - readonly
    - 原料格納スペースに格納されている資源の一覧
  - adjacent objects
    - "隣接"しているオブジェクトの一覧

#### DISASSEMBLER

- 概要：
  - 指定のターゲットから指定の資源を剥ぎ取る
- 仕様：
  - 指定のターゲットから指定の資源を剥ぎ取る
  - 指定できるターゲット種別はマテリアル、ユニット断片、ユニットである
  - 実際にターゲットをdisassembleするにはターゲットと接続状態であり、かつ隣接している必要がある（回路が接続されていないと、回路上にターゲットが存在しないので指定できない）
    - このことから、自身のユニット以外をdisassembleするにはまずCONNECTORで対象と接続する必要がある
  - disassembleを試みるには、disassemble対象とはぎ取る資源を指定し、1以上のエネルギーを投入する必要がある
    - disassemble対象のはぎ取る資源の化学結合エネルギーが投入エネルギーより小さい場合にdisassembleに成功する
    - 結合エネルギーが投入エネルギー以上である場合はdisassembleに失敗し、投入したエネルギーは消費され熱となる。また、投入エネルギーが結合エネルギーを大きく上回った場合も、投入エネルギーは全量消費される
    - 同時に複数のDISASSEMBLERからdisassemble対象になった場合は、個々の投入エネルギーが結合エネルギーを下回っていても、合計の投入エネルギーが結合エネルギーを上回ればdisassembleされる
  - 剥ぎ取られた資源はdisassemble対象に隣接する空間に出現する
- 回路仕様：
  - なし
- 生成仕様：
  - TBD
- 分解仕様：
  - TBD
- API：
  - recipe
    - readonly
    - このユニットの生成仕様
  - max composition
    - readonly
    - ユニット最大資源量
  - current composition
    - readonly
    - 現在のユニット資源量
  - damage
    - readonly
    - そのユニットを構成する資源の量からどれだけの資源量を失っているかを表す
    - `max composition - damage = current composition` は常に成り立つ
  - adjacentObjects
    - "隣接"しているオブジェクトの一覧

#### CONNECTOR

- 概要：
  - ゲームオブジェクトをCONNECTOR自身に結合する
- 仕様：
  - ゲームオブジェクトをCONNECTOR自身に結合する
  - ゲームオブジェクトに対して接続するCONNECTOR数には上限はない
- 回路仕様：
  - 結合したゲームオブジェクトと回路を繋げるかどうかは以下の3種類の設定がある
    - 常に接続しない
    - 常に接続する
    - 任意に接続/切断可能
- 生成仕様：
  - 回路接続しないCONNECTOR:
    - TBD
  - 回路接続するCONNECTOR:
    - TBD
  - 回路接続を任意に切断できるCONNECTOR:
    - TBD
- 分解仕様：
  - TBD
- API：
  - recipe
    - readonly
    - このユニットの生成仕様
  - max composition
    - readonly
    - ユニット最大資源量
  - current composition
    - readonly
    - 現在のユニット資源量
  - damage
    - readonly
    - そのユニットを構成する資源の量からどれだけの資源量を失っているかを表す
    - `max composition - damage = current composition` は常に成り立つ
  - connector status
    - 回路接続の状態を返す
  - adjacentObjects
    - "隣接"しているオブジェクトの一覧

#### CHANNEL

- 概要：
  - HULLの
- 仕様：
- 回路仕様：
  - なし
- 生成仕様：
  - TBD
- 分解仕様：
  - TBD
- API：
  - recipe
    - readonly
    - このユニットの生成仕様
  - max composition
    - readonly
    - ユニット最大資源量
  - current composition
    - readonly
    - 現在のユニット資源量
  - damage
    - readonly
    - そのユニットを構成する資源の量からどれだけの資源量を失っているかを表す
    - `max composition - damage = current composition` は常に成り立つ
  - adjacentObjects
    - "隣接"しているオブジェクトの一覧

#### COMPUTER

- 概要：
  - Synthetica Scriptで記述されたソフトウェアを実行し、回路的に接続しているユニットを制御する
- 仕様：
  - アセンブリ言語であるSynthetica Scriptを解釈し、実行する
  - COMPUTERはプログラムカウンタ、固定bit長のワーキングレジスタ、メモリの3要素から成る
    - つまり、プログラムとデータは分離していない（分離させたい場合は、データ領域にプログラムカウンタが侵入しないようなプログラムにする）
  - COMPUTERの生成時に指定できる性能は以下のふたつである
    - 動作周波数
      - tickあたり何命令を実行できるかを表す（例：10命令/tick）
        - 動作周波数がtickより遅い（例：1命令/3tick）設定も可能
    - メモリ容量
      - メモリの格納容量
  - TBD: COMPUTERは他のCOMPUTERのメモリ内容を読み取り/書き込みできるようにすべきかどうか
  - COMPUTERの動作（命令の実行）にはエネルギーを消費する
  - TBD: 仕様に矛盾がないか詰める: プログラムカウンタなし、ワーキングレジスタなし、メモリの変更不可、メモリ容量に上限ありのCOMPUTERは安価に生産・運用が可能で高速に動作（毎tickメモリの先頭から末尾までを実行）する
    - 例：ある条件を満たしたらあるユニットを動作させる、あるユニットにマクロを付与する、などの単一機能COMPUTER
- 回路仕様：
  - なし
- 生成仕様：
  - TBD
- 分解仕様：
  - TBD
- API：
  - recipe
    - readonly
    - このユニットの生成仕様
  - max composition
    - readonly
    - ユニット最大資源量
  - current composition
    - readonly
    - 現在のユニット資源量
  - damage
    - readonly
    - そのユニットを構成する資源の量からどれだけの資源量を失っているかを表す
    - `max composition - damage = current composition` は常に成り立つ
  - adjacentObjects
    - "隣接"しているオブジェクトの一覧

#### SENSOR

- 概要：
  - 遠距離の状態を計測する
- 仕様：
- 回路仕様：
  - なし
- 生成仕様：
  - TBD
- 分解仕様：
  - TBD
- API：
  - recipe
    - readonly
    - このユニットの生成仕様
  - max composition
    - readonly
    - ユニット最大資源量
  - current composition
    - readonly
    - 現在のユニット資源量
  - damage
    - readonly
    - そのユニットを構成する資源の量からどれだけの資源量を失っているかを表す
    - `max composition - damage = current composition` は常に成り立つ
  - adjacentObjects
    - "隣接"しているオブジェクトの一覧

#### MOVER

- 概要：
  - エージェントを移動させる
- 仕様：
  - エネルギーを消費し、自身（が所属しているゲームオブジェクト）に任意の方向の加速度を追加する
    - 追加される加速度の大きさは、TBD （エネルギーを自身（が所属しているゲームオブジェクト）の質量で割った値？）
- 回路仕様：
  - なし
- 生成仕様：
  - TBD
- 分解仕様：
  - TBD
- API：
  - recipe
    - readonly
    - このユニットの生成仕様
  - max composition
    - readonly
    - ユニット最大資源量
  - current composition
    - readonly
    - 現在のユニット資源量
  - damage
    - readonly
    - そのユニットを構成する資源の量からどれだけの資源量を失っているかを表す
    - `max composition - damage = current composition` は常に成り立つ
  - adjacentObjects
    - "隣接"しているオブジェクトの一覧

### Synthetica Script

- Synthetica Assembler
- Synthetica C

### 自己複製エージェント仕様

#### 非生命複製子

- 動作状態の自己複製単一目的ASSEMBLER（ `M5,O632,C151,E692` ）

#### 受動自律エージェント

- ハードウェア
  - HULL
    - 外側
      - CHANNEL: mineral
      - CHANNEL: organic
      - CHANNEL: chemical
      - CHANNEL: energy
    - 内側
      - 万能ASSEMBLER
      - COMPUTER
- ソフトウェア
  - a.成長 → b.複製資源回収 → c.自己複製 → b のライフサイクル
  - ## a.成長
  - b.複製資源回収
    - HULLの内容量を監視し、自己複製に必要な資源
  - ## c.自己複製

## 用語

- 隣接
- 結合
- recipe
- 「ユニット最大資源量（max composition）」
- 「現在のユニット資源量（current composition）」

## TODO

- HULLへ直接ユニットが固定されるのではなく、CONNECTORを介するように変更する
- ASSEMBLERが直接生産ユニットを設置するのではなく、設置起動を行うユニットを介在させれば良いのではないか
