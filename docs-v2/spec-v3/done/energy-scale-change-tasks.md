# エネルギースケール変更タスクリスト

## 概要

**案2（分割計算方式）** と **案4（コスト見直し）** の組み合わせを採用し、以下の課題を解決する：

- 課題1: 16bit制限（最大65,535）への対応
- 課題2: 小数回避とCOMPUTER実行コストの精度維持

### 採用方式: 1024進法（2^10）

- 上位16bit: 1024E単位（2^10）
- 下位16bit: 1E単位
- キャリー/ボロー処理がビット演算で効率的に実装可能

## 変更タスクリスト

### 1. エネルギー単位の再定義

- [x] 基本エネルギー単位を10倍に変更（1E → 10内部単位）
- [x] エネルギー表現を上位16bit（1024E単位）+ 下位16bit（E単位）の32bit相当に拡張
- [x] 仕様書全体でのエネルギー表記方法の統一（例：164,400E → 160×1024E + 880E = [0x00A0][0x0370]）
- [x] energy-definition.md作成（エネルギー単位定義仕様）
- [x] energy-constants.h作成（共通定数ヘッダー）

### 2. game-world-requirement.md の更新

- [x] エネルギー表記を新単位系に変更
- [x] 各ユニットの生成コスト計算式を更新
  - [x] COMPUTERメモリコスト: 500E/B → 50E/B
  - [x] COMPUTER基本コスト: `5000E + ceil((動作周波数/5)^2 × 1000E)` → `500E + ceil((動作周波数/5)^2 × 100E)`（1/10に削減）
  - [x] ASSEMBLER基本コスト: `8000E + (assemble_power × 2000E)` → `800E + (assemble_power × 200E)`（1/10に削減）
  - [x] DISASSEMBLER基本コスト: `2000E + (disassemble_power × 200E)` → `200E + (disassemble_power × 100E)`（1/10に削減）
  - [ ] HULL容量コストの段階制導入を検討（容量100まで2E/容量、それ以上は1E/容量など）→ 現状維持
  - [x] 生産エネルギー比率の見直し:
    - [x] ASSEMBLER: 0.5 → 0.2への調整
    - [x] COMPUTER: 0.2 → 0.1への調整
  - [x] 生産中ユニットの初期コスト: 構成エネルギーの10% → 5%に削減
- [x] 熱ダメージ計算式の単位調整（× 0.1を削除し、整数化）
- [x] エネルギー消費に関する全ての数値を整数化

### 3. synthetica-script.md の更新

- [x] COMPUTER命令実行コストを整数化
  - [x] 1バイト命令: 0.1E → 1E
  - [x] 3バイト命令: 0.3E → 3E
  - [x] 4バイト命令: 0.4E → 4E
  - [x] 5バイト命令: 0.5E → 5E
  - [x] 絶対アドレス命令: 0.6E → 6E
- [x] テンプレートマッチングコストの整数化
- [x] エネルギー計算用の新命令追加（1024進法32bit演算用）
  - [x] ADD_E32（エネルギー32bit加算: キャリー処理は下位10bitオーバーフロー時）
  - [x] SUB_E32（エネルギー32bit減算: ボロー処理は下位が負の時）
  - [x] CMP_E32（エネルギー32bit比較: 上位優先、同じなら下位比較）
  - [x] SHR_E10（エネルギー値を1024で除算: 10bit右シフト）
  - [x] SHL_E10（エネルギー値を1024倍: 10bit左シフト）

### 4. energy-consumption.md の更新

- [x] 全ての計算例を新単位系で書き直し
- [x] 16bit範囲内に収まることの確認
- [x] 自己複製エージェントのコスト例を更新

### 5. 実装への影響の文書化

- [x] 1024進法エネルギー計算のサンプルコード作成
  - [x] C言語レベル: `typedef uint32_t energy_t;` として統合的に扱う
  - [x] アセンブリレベル: 必要に応じて上位/下位を分離
  - [x] 最適化の選択: コンパイラが自動判断
- [x] 上位16bitのみでの概算計算の例（1024E単位での大雑把な計算）
- [x] エネルギー不足判定の実装例
- [ ] ビット演算を活用した効率的な実装方法
- [x] synthetica-c-compiler.md への詳細仕様記載

### 6. example_compiled_16bit.md の更新

- [x] エネルギー関連の定数を新単位系に変更
- [x] 32bitエネルギー計算を使用するように更新（必要に応じて）

### 7. バランス調整の検証

- [x] 最小構成エージェントの総コストが16bit×2で扱えることを確認
- [x] エネルギーソースの産出量の調整案作成
- [x] 各種アクションのエネルギーコストバランスの確認

### 8. 移行計画の作成

- [x] 既存仕様からの段階的移行手順（移行完了）
- [x] 後方互換性の考慮事項（不要と判断）

## 優先順位

1. **高優先度**: タスク1-4（仕様の基本的な変更） ✓ 完了
2. **中優先度**: タスク5-6（実装支援文書） ✓ 完了
3. **低優先度**: タスク7-8（検証と移行計画） ✓ 完了

## 実施状況

- 作成日: 2025-07-28
- 最終更新: 2025-07-28（全タスク完了）
- ステータス: 全タスク（1-8）完了

## 移行完了の確認

移行チェック実施結果：

- ✓ すべての仕様ファイルで小数エネルギー値を整数化完了
- ✓ 1024進法エネルギーシステムを全面的に採用
- ✓ 残存していた古いエネルギー値を修正:
  - energy-consumption.md: COMPUTER生成式の例を修正
  - analysis-report.md: 各ユニットの生成コストを新値に更新
  - synthetica-script.md: テンプレートマッチング失敗時コストを整数化

## 1024進法の利点

- **ビット演算での効率的な実装**
  - 下位10bitマスク: `lower & 0x3FF`
  - 上位へのキャリー: `upper += (lower >> 10)`
  - 1024での除算: 10bit右シフト
  - 1024倍: 10bit左シフト

- **メモリ効率**
  - 最大値: 65,535 × 1024 + 1,023 = 67,108,863E
  - 十分な範囲をカバー

## 備考

- これらのタスクを順次実行することで、16bit制限と小数回避の両方の課題を解決する
- 動力と材料の分離（案7）は将来的な実装として別途検討
