# 万能複製エージェント実現のための追加命令提案

## 概要

現在のコンパイル結果分析により、万能複製のような複雑な機能を実現するために以下の命令追加が望まれます。

## 1. ビットシフト命令（実装済み）

- **SHL (0xC2)** - 論理左シフト
- **SHR (0xC3)** - 論理右シフト
- **SAR (0xC4)** - 算術右シフト

これにより、16bit値の組み立て（high << 8 | low）が可能になりました。

## 2. メモリブロック転送命令（提案）

### MEMCPY命令

```
オペコード: 0xC5
フォーマット: 5バイト命令
動作: メモリブロックの高速転送
パラメータ:
  - 第2,3バイト: 転送元アドレス（Aレジスタ相対）
  - 第4,5バイト: 転送バイト数
使用例:
  MEMCPY
  0x00 0x00   ; 転送元オフセット（Aレジスタ + 0）
  0x64 0x00   ; 100バイト転送
```

効果：

- プログラム転送の大幅な高速化
- エネルギー効率の改善
- コードサイズの削減

## 3. 動的ユニット操作命令（提案）

### UNIT_MEM_WRITE_DYN命令

```
オペコード: 0x9B
フォーマット: 4バイト命令
動作: レジスタで指定したアドレスへのユニットメモリ書き込み
パラメータ:
  - 第2バイト: ユニット指定（既存と同じ）
  - 第3バイト: アドレス指定レジスタ（0=A, 1=B, 2=C, 3=D）
  - 第4バイト: 未使用
使用例:
  ; Cレジスタにアドレスが入っている場合
  UNIT_MEM_WRITE_DYN
  0xC1        ; COMPUTER[1]
  0x02        ; Cレジスタのアドレスへ
  0x00        ; 未使用
```

効果：

- ループ内での動的アドレス書き込みが可能
- プログラム転送の簡略化

## 4. スタック操作命令（提案）

### PUSH/POP命令

```
PUSH_A (0x1E): Aレジスタをスタックにプッシュ
PUSH_B (0x1F): Bレジスタをスタックにプッシュ
POP_A  (0x2E): スタックからAレジスタにポップ
POP_B  (0x2F): スタックからBレジスタにポップ
```

効果：

- 関数呼び出しの実装が容易に
- レジスタの一時保存が簡単に
- より構造化されたプログラミングが可能

## 5. 条件付き実行命令（提案）

### CMOV命令（条件付き移動）

```
オペコード: 0xC6
フォーマット: 5バイト命令
動作: 条件が真の場合のみレジスタ移動
パラメータ:
  - 第2バイト: 条件（0=Z, 1=NZ, 2=C, 3=NC）
  - 第3バイト: ソースレジスタ
  - 第4バイト: 宛先レジスタ
  - 第5バイト: 未使用
```

効果：

- 分岐を減らしてパイプライン効率向上
- 条件処理の簡略化

## 6. 複合演算命令（提案）

### LEA命令（実効アドレス計算）

```
オペコード: 0xC7
フォーマット: 5バイト命令
動作: A = B + C * scale + offset
パラメータ:
  - 第2バイト: scale（1, 2, 4, 8）
  - 第3,4バイト: offset（16bit）
  - 第5バイト: 未使用
```

効果：

- 配列アクセスの高速化
- アドレス計算の簡略化

### LEA命令の具体的な利用場面と実装比較

#### 1. 配列アクセスの最適化

```assembly
; 構造体配列 struct[i] のフィールドアクセス
; 構造体サイズ = 8バイト、フィールドオフセット = 4

; LEA命令がある場合（1命令）
LEA A, B, C, 8, 4   ; A = B + C * 8 + 4

; LEA命令がない場合（5命令）
MOV A, C            ; インデックスをコピー
SHL A, 3            ; * 8 (左3ビットシフト)
ADD A, B            ; ベースアドレスを加算
MOV D, #4           ; オフセットをロード
ADD A, D            ; オフセットを加算
```

#### 2. 2次元配列アクセス

```assembly
; array[i][j] のアクセス（行サイズ = 16）

; LEA命令がある場合（2命令）
LEA A, D, B, 16, 0  ; A = D + B * 16 (行の先頭)
ADD A, C            ; 列オフセットを加算

; LEA命令がない場合（4命令）
MOV A, B            ; 行インデックス
SHL A, 4            ; * 16
ADD A, D            ; ベースアドレス
ADD A, C            ; 列インデックス
```

#### 3. ループ内での効率的なアドレス計算

```assembly
; バッファコピーループ

; LEA命令がある場合
loop_with_lea:
    LEA A, src_base, D, 1, 0    ; src + i
    MOV B, [A]
    LEA A, dst_base, D, 1, 0    ; dst + i
    MOV [A], B
    INC D
    CMP D, #size
    BLT loop_with_lea

; LEA命令がない場合
loop_without_lea:
    MOV A, D
    ADD A, #src_base
    MOV B, [A]
    MOV A, D
    ADD A, #dst_base
    MOV [A], B
    INC D
    CMP D, #size
    BLT loop_without_lea
```

#### 実装の比較

**メモリアクセス効率**

- LEA命令あり: 1命令で複雑なアドレス計算
- LEA命令なし: 3-5命令必要

**コードサイズ**

- LEA命令あり: 5バイト/命令
- LEA命令なし: 6-15バイト（複数命令）

**実行サイクル**

- LEA命令あり: 1サイクル
- LEA命令なし: 3-5サイクル

#### 実装判断

LEA命令は特に構造体配列、多次元配列、タイトなループ内でのアドレス計算で大きな利点があります。しかし、現在の主要課題（自己複製エージェント）では単純な線形メモリアクセスが主体で、複雑なアドレス計算の必要性が低いため、**現時点では実装を見送ります**。

将来的により複雑なデータ構造を扱うエージェントが必要になった際に、再検討することとします。

## 実装優先度

1. **高優先度**：
   - メモリブロック転送（MEMCPY）
   - 動的ユニット操作（UNIT_MEM_WRITE_DYN）

2. **中優先度**：
   - スタック操作（PUSH/POP）
   - 条件付き実行（CMOV）

3. **低優先度**：
   - 複合演算（LEA）

## まとめ

これらの命令追加により、以下が実現可能になります：

1. **効率的なプログラム転送** - MEMCPYによる高速転送
2. **動的メモリアクセス** - レジスタ指定によるユニット操作
3. **構造化プログラミング** - スタック操作による関数呼び出し
4. **最適化されたコード** - 条件付き実行と複合演算

特に最初の2つは、現在の万能複製実装の主要な課題を直接解決するため、優先的な実装が推奨されます。
