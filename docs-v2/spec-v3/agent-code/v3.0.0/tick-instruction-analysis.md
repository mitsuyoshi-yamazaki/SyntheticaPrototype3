# 現在の時刻を取得する命令の必要性検討

## 概要

tickが進んだことに依存する処理を実装する要望に対し、システム根幹の情報を直接露出させない方法を検討する。

## 現状分析

### 現在のタイミング依存処理の実装方法

1. **ポーリング方式** (example.cでの実装)

   ```c
   while (1) {
     if (!is_assembling(0)) {
       break;
     }
   }
   ```

   - ASSEMBLERの状態を繰り返しチェック
   - CPU周波数×ループ回数分のエネルギーを消費
   - 非効率だが確実な方法

2. **状態変化の検出**
   - ユニットの操作メモリ領域から状態を読み取る
   - 値が変化したかどうかで判断
   - 同じtickで複数回チェックしても値は変わらない

### タイミング依存処理が必要な場面

1. **ユニット生産完了待機**
   - 現状: `is_assembling()`のポーリング
   - 問題: 同一tick内での無駄なチェック

2. **エネルギー量の監視**
   - 現状: エネルギー量を定期的にチェック
   - 問題: 同一tick内では値が変化しない

3. **外部イベントの検出** (v4でのSENSOR)
   - 環境変化の検出
   - 他エージェントの行動検出

## 検討案

### 案1: 直接的なtick取得命令 (非推奨)

```assembly
GET_TICK    ; A = 現在のtick値
```

**問題点:**

- システム内部情報の露出
- tick値に依存したコードは移植性が低い
- ゲーム世界の抽象性を損なう

### 案2: 状態変化フラグ方式

各ユニットの操作メモリ領域に「前回読み取り時からの変化フラグ」を追加:

```
COMPUTER操作メモリ:
0x03: [R] bool 状態変化フラグ（前回このアドレスを読んでから値が変化したか）
```

**利点:**

- tick情報を直接露出しない
- 必要な情報（変化の有無）のみ提供
- 効率的なポーリングが可能

**実装例:**

```c
// 効率的な待機ループ
while (is_assembling(0)) {
    if (!has_state_changed(0)) {
        // 状態が変化していないので待機
        continue;
    }
    // 状態が変化したので再チェック
}
```

### 案3: イベントカウンタ方式

各ユニットに「イベントカウンタ」を追加:

```
ASSEMBLER操作メモリ:
0x04: [R] uint イベントカウンタ（生産完了、エラー発生等でインクリメント）
```

**利点:**

- イベント発生を確実に検出
- 複数イベントの見逃しを防ぐ
- tick情報を隠蔽

**実装例:**

```c
unsigned int last_event = get_event_counter(0);
while (1) {
    unsigned int current_event = get_event_counter(0);
    if (current_event != last_event) {
        // 何かイベントが発生した
        if (!is_assembling(0)) {
            break;  // 生産完了
        }
        last_event = current_event;
    }
}
```

### 案4: 現状維持＋最適化ガイドライン

特別な命令を追加せず、効率的なコーディングパターンを文書化:

**推奨パターン:**

1. **適切な待機間隔の設定**

   ```c
   // 低頻度チェック（省エネ）
   for (int wait = 0; wait < 10; wait++) {
       // 何か軽い処理
   }
   // 状態チェック
   ```

2. **複数状態の同時チェック**

   ```c
   // 複数の状態を一度にチェックしてから分岐
   unsigned int assembler_state = is_assembling(0);
   unsigned int energy = get_energy_amount(0);

   if (!assembler_state && energy > 1000) {
       // 両方の条件が満たされた
   }
   ```

## 推奨案: 案4（現状維持＋最適化ガイドライン）

### 理由

1. **シンプルさの維持**
   - 新しい概念や命令を追加しない
   - 既存の仕組みで十分対応可能

2. **ゲーム性の観点**
   - 効率的なコーディングが競争優位性につながる
   - プレイヤーの工夫の余地を残す

3. **実装の容易さ**
   - アプリケーション側の変更が不要
   - 仕様の複雑化を避ける

### 実装ガイドライン（文書化すべき内容）

1. **エネルギー効率的な待機パターン**
   - ビジーウェイトの回避方法
   - 適切なチェック間隔の設定

2. **状態管理のベストプラクティス**
   - 前回値の保存と比較
   - 複数状態の効率的な監視

3. **動作周波数の活用**
   - 低頻度タスク用の低周波数COMPUTER
   - 用途に応じた周波数設定

## 結論

現在の時刻を取得する命令は**不要**と判断する。

代わりに、エネルギー効率的なプログラミングパターンを文書化し、プレイヤーが工夫できる余地を残すことで、より豊かなゲーム性を実現する。

## TODO

- [ ] エネルギー効率的なコーディングパターン集の作成
- [ ] 待機処理のサンプルコード集の作成
- [ ] v3.0.0準拠の自己複製エージェントで効率的な実装例を示す
